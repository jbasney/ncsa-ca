#! /bin/sh

if [ "x${GLOBUS_LOCATION}" = "x" ]; then
    echo "ERROR: please set GLOBUS_LOCATION before running this script!"
    exit 1
fi

. ${GLOBUS_LOCATION}/libexec/globus-script-initializer

#
# Sample script to generate a certificate request which can be sent 
# to the NCSA CA, who will sign it. This script uses ncsa-ca.conf. 
#
# When generating a certificate request and private key for a 
# globus gatekeeper daemon, use the -nopw option, so the
# key is not protected by pass phrase. 
#
VERSION="0.4.1"
PROGRAM_NAME=`echo $0 | ${GLOBUS_SH_SED-sed} 's|.*/||g'`

short_usage="$PROGRAM_NAME [-help] [ options ...]"

long_usage () {
    ${GLOBUS_SH_CAT-cat} >&2 <<EOF

${short_usage}

  Options:
    -cn <name>         : Common name of the user
    -gatekeeper <name> : Create certificate for a gatekeeper named <name>
    -host <name>       : Create host certificate for a host named <name>
    -ldap <name>       : Create ldap certificate for a host named <name>
    -dir <dir_name>    : User certificate directory [ '$HOME/.globus' ]
    -cert <file>       : File name of the certificate
    -key <file>        : File name of the user key
    -req <file>        : File name of the certificate request
    -nopw              : Create certificate without a passwd
    -int[eractive]     : Prompt user for each component of the DN
    -force             : Overwrites prexisting certifictes
    -resubmit          : Resubmit a previously generated certificate request.
EOF
}


	### BEGIN   inserted by configure ###

	globus_args_short_usage()
	{
	    ${GLOBUS_SH_CAT-cat} 1>&2 <<EOF

Syntax : ${short_usage}

Use -help to display full usage.

EOF
	}

	globus_args_option_error()
	{
	    ${GLOBUS_SH_CAT-cat} 1>&2 <<EOF

Error, argument $1 : $2
EOF
	    globus_args_short_usage
	    exit 1
	}

	
	globus_args_unrecognized_option()
	{
	    globus_args_option_error $1 "unrecognized option"
	    exit 1
	}	

	_done=no
	_n=1
	while [ "$_done" = no -a "$_n" -le "$#" ] ; do
	    _tmp="echo \"\$${_n}\""
	    _arg="`eval ${_tmp}`"
	    case "${_arg}" in
		-help | -usage)
		    long_usage
		    exit 0
		    ;;
		-version)
		    echo "ncsa-cert-request $VERSION"
		    exit 0
		    ;;
	        --)
		    _done=yes
		    ;;
		--*)
		    globus_args_option_error $1 "double-dashed option syntax is not allowed"
		    ;;
		*)
		    _n=`${GLOBUS_SH_EXPR-expr} $_n + 1`
		    ;;
	    esac
	done
	_n=
	_tmp=
	_arg=
	_done=
	### END   inserted by configure ###



gssapi_authentication=openssl

secconfdir="/etc/grid-security"

#SSL related needs
PATH=${GLOBUS_LOCATION}/bin:${PATH}
SSL_EXEC="${GLOBUS_LOCATION}/bin/openssl"
# CA_CONFIG should end up being $GL/share/gsi_ncsa_ca_tools/ncsa-ca.conf
# so $datadir should resolve to the share directory in $GL
CA_CONFIG="${datadir}/gsi_ncsa_ca_tools/ncsa-ca.conf"

# TEMP FILES
REQ_INPUT=${secconfdir}/req_input.$$
REQ_OUTPUT=${secconfdir}/req_output.$$
REQ_HEAD=${secconfdir}/req_header.$$


# DEFault Generated Files
DEF_GLOBUS_DIR="${HOME}/.globus"            # as with ncsa-cert-retrieve, do we need to keep this entry?
DEF_CERT_FILE="${secconfdir}/hostcert.pem"
DEF_KEY_FILE="${secconfdir}/hostkey.pem"
DEF_REQUEST_FILE="${secconfdir}/hostcert_req.pem"
DEF_REQUEST_ID_FILE="${secconfdir}/ncsa_request_id"

#
# these need to be added into the code below somewhere - cmp
#
DEF_LDAP_CERT_FILE="${secconfdir}/ldapservercert.pem"
DEF_LDAP_KEY_FILE="${secconfdir}/ldapserverkey.pem"
DEF_LDAP_REQUEST_FILE="${secconfdir}/ldapservercert_req.pem"
DEF_LDAP_REQUEST_ID_FILE="${secconfdir}/ldap_request_id"


# Info sent with the certificate
SUBJECT=
USERID="`${GLOBUS_SH_WHOAMI-whoami}`"
HOST="`${bindir}/globus-hostname`"
SERVICE=
SERVICE_HOST=
INTERACTIVE=
NO_DES=
RESUBMIT=FALSE

CERTREQ="${bindir}/grid-cert-request" # note that this variable is not being used in any
                                      #   location
                                      #

CONTACT_EMAIL_ADDR="consult@alliance.paci.org"
CONTACT_URL="http://www.ncsa.uiuc.edu/UserInfo/Alliance/GridSecurity/"
USER_AGENT="ncsa-cert-request/$VERSION"

cleanup () {
  : 
  # ${GLOBUS_SH_RM-rm} -f ${REQ_HEAD} ${REQ_INPUT} ${REQ_OUTPUT}
}

trap cleanup 0

security_conf=${secconfdir}/grid-security.conf

# See if we can proceed
. ${security_conf}



## Other cleanup routines.


abort_cleanup () {
  :
  cleanup
  ${GLOBUS_SH_RM-rm} -f ${CERT_FILE} ${KEY_FILE} ${REQUEST_FILE}
}

readCommandLine () {
  # Expects $* from the shell invocation

  while [ "X$1" !=  "X" ]
  do
    case $1 in
      -\?|-h|-help|-usage)
         long_usage
         exit 0
         ;;

     -cn | -commonname)
       	 COMMON_NAME="$2"
         shift ; shift
         ;;

     -gatekeeper)
         SERVICE="gatekeeper"
	 COMMON_NAME="$2"
         NO_DES="-nodes"
         shift ; shift
         ;;

     -host)
         SERVICE="host"
	 SERVICE_HOST="$2"
         NO_DES="-nodes"
         shift ; shift
         ;;

     -ldap)
         SERVICE="ldap"
         SERVICE_HOST="$2"
         NO_DES="-nodes"
         shift ; shift
         ;;

     -dir)
         DEF_GLOBUS_DIR="$2"
         shift ; shift
         ;;

     -cert|-certificate)
         DEF_CERT_FILE="$2"
         shift ; shift
        ;;

     -key)
	 DEF_KEY_FILE="$2"
	 shift ; shift
	 ;;

     -req|-request)
	 DEF_REQUEST_FILE="$2"
	 shift ; shift
	 ;;

     -nopw|-nodes|-nopassphrase)
         NO_DES="-nodes"
         shift
         ;;

     -int|-interactive)
         INTERACTIVE="TRUE"
         shift
         ;;
     -force)
         FORCE="TRUE"
         shift
         ;;
     -resubmit)
         RESUBMIT="TRUE"
	 shift
	 ;;
     *)
	 globus_args_unrecognized_option "$1"
         ;;
    esac
  done

}



###########################################################
# createInputFile
#   Generate a inputfile to be given to SSLEAY that fully 
#   specifies the DN of the user
#   files
###########################################################
createInputFile () {
  _common_name="$1"

# Parse the ssleay configuration file, to determine the
# correct default parameters

${GLOBUS_SH_AWK-awk}  < ${CA_CONFIG} '
 
  /^\[ req_distinguished_name \]/ {
     start_parsing=1;
     next;
  }

  /^\[ .*/ {
     start_parsing=0;
     next;
  }

  /^[a-zA-Z0-9\.]*_default[ \t]*=/ && start_parsing==1 {
     split($0, a, "=");
     # default value is in a[2], but we should strip of leading ws
     for(i=1;substr(a[2],i,1) == " " || substr(a[2],i,1) == "\t"; i++);
     print substr(a[2], i);
     next;
}
'

   echo ${_common_name}
}


###########################################################
# createServiceRequestHeader
###########################################################
createServiceRequestHeader () {

    ${GLOBUS_SH_CAT-cat} <<EOF
This is a Certificate Request file for an Alliance Certificate.

This request should already have been submitted to the Alliance
CA for approval and you will be notified by email when your
certificate is ready. Your request ID number can be found in the
file: ${REQUEST_ID_FILE}

If you have any questions or concerns please visit
 
${CONTACT_URL}
 
or send mail to Alliance consulting at ${CONTACT_EMAIL_ADDR}
   
=========================================================================
Certificate Subject:

    ${SUBJECT}


EOF
  
}

###########################################################
# createRequestHeader
###########################################################
createRequestHeader () {
  # This is the information that is sent with the certificate

    ${GLOBUS_SH_CAT-cat} <<EOF

This is a Certificate Request file for an Alliance Certificate.

This request should already have been submitted to the Alliance
CA for approval and you will be notified by email when your
certificate is ready. Your request ID number can be found in the
file: ${REQUEST_ID_FILE}

If you have any questions or concerns please visit
 
${CONTACT_URL}
 
or send mail to Alliance consulting at ${CONTACT_EMAIL_ADDR}
   
=========================================================================
Certificate Subject:

    ${SUBJECT}


EOF
  
}



###########################################################
# checkGlobusSystem:  
#   Ensure that the NCSA SSLeay Configuration files
#   have been created by the Globus Sys.Admin
###########################################################
checkGlobusSystem () {

  _matches=`${GLOBUS_SH_GREP-grep} -c "Not Configured" $CA_CONFIG 2> /dev/null`
  if [ $_matches -ne 0 ] ; then
    echo
    echo "The NCSA Configuration files have not been setup."   1>&2
    echo "Please have your system administrator install the"   1>&2
    echo "the ncsa-ca package."                                1>&2
    exit 1
  fi
}



###########################################################
# check4Certs:  
#   Ensure that the user does not overwrite their
#   security files.
###########################################################
check4Certs () {
  _exists="FALSE"

  if [ -r ${REQUEST_FILE} ] ; then
     ${GLOBUS_SH_PRINTF-printf} "\n    ${REQUEST_FILE} already exists" 1>&2
     ${GLOBUS_SH_CHMOD-chmod} u+w ${REQUEST_FILE}
    _exists=TRUE
  fi
  if [ -r ${CERT_FILE} ] ; then
     ${GLOBUS_SH_PRINTF-printf} "\n    ${CERT_FILE} already exists" 1>&2
     ${GLOBUS_SH_CHMOD-chmod} u+w ${CERT_FILE}
    _exists=TRUE
  fi
  if [ -r ${KEY_FILE} ] ; then
     ${GLOBUS_SH_PRINTF-printf} "\n    ${KEY_FILE} already exists" 1>&2
     ${GLOBUS_SH_CHMOD-chmod} u+w ${KEY_FILE}
    _exists=TRUE
  fi

  
  if [ "X$_exists" = "XTRUE" ] ; then
    if [ "X$FORCE" = "XTRUE" ] ; then
      ${GLOBUS_SH_RM-rm} -f ${CERT_FILE} ${KEY_FILE} ${REQUEST_FILE}
      echo
      echo
    else 
      ${GLOBUS_SH_PRINTF-printf} "\nPlease remove this (these) file(s) and run the script\n" 1>&2
      ${GLOBUS_SH_PRINTF-printf} "\nIf you are attempting to resubmit an already generated request\n" 1>&2
      ${GLOBUS_SH_PRINTF-printf} "use the '-resubmit' option.\n" 1>&2
      exit 1
    fi
  fi

}

###########################################################


###########################################################
# setupGlobusDir:  
#   Create a directory in the HOME directory of the user
#   to store globus related stuff.
###########################################################
setupGlobusDir () {
 
  if [ ! -d ${GLOBUS_DIR} ] ; then
    ${GLOBUS_SH_MKDIR-mkdir} ${GLOBUS_DIR}
    if [ $? -ne 0 ] ; then
      exit $?
    fi 
  fi
}

#############################################################


###########################################################
# getUserCN
#   Determine the name of the user
###########################################################
getUserCN () {

   _common_name="${COMMON_NAME}"

   # 1. Command line argument
   # 2. Query the system
   # 3. Prompt the user

   if [ -z "${_common_name}" ] ; then 
     ${GLOBUS_SH_FINGER-finger} -lm ${USERID}  >/dev/null 2>&1
     if [ $? -eq 0 ] ; then 
       _common_name="`${GLOBUS_SH_FINGER-finger} -lm ${USERID}         |\
                      ${GLOBUS_SH_GREP-grep} ${USERID}               |\
                      ${GLOBUS_SH_AWK-awk} -F: '{ print $3; exit }' |\
                      ${GLOBUS_SH_CUT-cut} -c2- `"
     fi
   fi

   # For ncsa-cert-request, always give the user a chance to enter this
   ${GLOBUS_SH_PRINTF-printf} "Enter your name, e.g., John Smith " 1>&2
   if [ -n "${_common_name}" ] ; then
      ${GLOBUS_SH_PRINTF-printf} "[${_common_name}]" 1>&2
   fi
   ${GLOBUS_SH_PRINTF-printf} ": " 1>&2
   read _common_name_input

   if [ -n "${_common_name_input}" ]; then
     _common_name=${_common_name_input}
   fi

   echo ${_common_name}
}



###########################################################
# getHostCN
#   Determine the name of the host for a host certificate
###########################################################
getHostCN () {

   _common_name="${COMMON_NAME}"

   # 1. Command line -cn argument
   # 2. Create from -host argument

   if [ -z "${_common_name}" ] ; then 
      # Check SERVICE_HOST and make sure it looks like a FQDN
      ${GLOBUS_SH_ECHO-echo} ${SERVICE_HOST} | ${GLOBUS_SH_GREP-grep} "\." >/dev/null 2>&1
      if [ $? -eq 1 ] ; then
	${GLOBUS_SH_ECHO-echo} "The hostname ${SERVICE_HOST} does not appear to be fully qualified." 1>&2
	${GLOBUS_SH_PRINTF-printf} "Do you wish to continue? [n] " 1>&2
	read _response

	case X${_response} in
	Xy|XY|Xyes|XYES|XYes)
	  ;;

	*)
	  ${GLOBUS_SH_ECHO-echo} "Aborting" 1>&2
	  exit 1
	  ;;
	esac
      fi
      
      case ${SERVICE} in
          host)
              _common_name="host/${SERVICE_HOST}"
              ;;
          ldap)
              _common_name="ldap/${SERVICE_HOST}"
              ;;
          *)
              _common_name="host/${SERVICE_HOST}"
              ;;
       esac
   fi

   echo ${_common_name}
}



###########################################################
# createCerts
#   Create the certificate, key, and certificate request
#   files
###########################################################
createCerts () {
  
  if [ -z "${SERVICE}" ] ; then
    echo "A certificate request and private key is being created."
    echo "You will be asked to enter a PEM pass phrase."
    echo "This pass phrase is akin to your account password, "
    echo "and is used to protect your key file."
    echo "If you forget your pass phrase, you will need to"
    echo "obtain a new certificate."
    echo
  fi

  #------------------------
  # Create the Certificate File
  umask 022
  ${GLOBUS_SH_TOUCH-touch} ${CERT_FILE}



  umask 266
  #------------------------
  # Create the Key and Request Files

  if [ -n "${INTERACTIVE}" ] ; then
    ${SSL_EXEC} req -new -keyout ${KEY_FILE} -out ${REQ_OUTPUT} \
              -config ${CA_CONFIG} ${NO_DES}
    RET=$?
  else
    createInputFile "${COMMON_NAME}" >${REQ_INPUT}

    ${SSL_EXEC} req -new -keyout ${KEY_FILE} \
              -out ${REQ_OUTPUT} -config ${CA_CONFIG} \
              ${NO_DES} < ${REQ_INPUT} 
    RET=$?

    # You can't separate the SSLEAY output, it all goes to stderr
    # including the prompts.
    # Don't remove ssleay output on error as it may be useful
    if [ ${RET} -eq 0 ] ; then
      ${GLOBUS_SH_CLEAR-clear}
    fi

    ${GLOBUS_SH_RM-rm} -f ${REQ_INPUT}
  fi

  if [ ${RET} -ne 0 ] ; then
     echo "Error number ${RET} was returned by " 1>&2
     echo "   ${SSL_EXEC}"                    1>&2
     exit ${RET}
  fi

  umask 022
  #------------------------
  # Insert instructions into the request file


  SUBJECT="`${SSL_EXEC} req -text -noout < ${REQ_OUTPUT} 2>&1 |\
            ${GLOBUS_SH_GREP-grep} 'Subject:' | ${GLOBUS_SH_AWK-awk} -F: '{print $2}' |\
            ${GLOBUS_SH_CUT-cut} -c2- `"

  #Convert the subject to the correct form.
  SUBJECT=`echo "/"${SUBJECT} | ${GLOBUS_SH_SED-sed} -e 's|, |/|g'`

  if [ -z "${SERVICE}" ] ; then
	  createRequestHeader >${REQ_HEAD}
  else
	  createServiceRequestHeader >${REQ_HEAD}
  fi

  # Finalize the Request file.
  ${GLOBUS_SH_CAT-cat} ${REQ_HEAD} ${REQ_OUTPUT} >${REQUEST_FILE}
  ${GLOBUS_SH_RM-rm} -f ${REQ_HEAD} ${REQ_OUTPUT}
}



# DEFUNCT ###
###########################################################
# getPassPhrase
#   Prompt the user for the PEM pass phrase
###########################################################
getPassPhrase () {

   _pass_phrase=
   _double_check=

   ${GLOBUS_SH_PRINTF-printf} "Enter PEM pass phrase:  " 
   ${GLOBUS_SH_STTY-stty} -echo
   read _pass_phrase
   while [ "X${_pass_phrase}" != "X${_double_check}" ]
   do
     ${GLOBUS_SH_PRINTF-printf} "\nReenter PEM pass phrase: "
     read _double_check

     if [ "X${_pass_phrase}" != "X${_double_check}" ] ; then 
       _double_check=
       ${GLOBUS_SH_PRINTF-printf} "\nEnter PEM pass phrase:   "
       read _pass_phrase
     fi
   done
   echo
   ${GLOBUS_SH_STTY-stty} echo

   PASS_PHRASE="${_pass_phrase}"
}


###########################################################
# printPostData
#
# Given a variable name and a value print a properly
# encoded string for inclusion in POST data.
#
###########################################################
printPostData () {
  var=$1
  value=$2

  # Stick output into a variable and then print the variable. We
  # need to do it this way because sed on some systems (e.g. IRIX
  # 6.5) sticks a carriage return at the end of it's output.
  #
  # Double up on percents in sed script since it goes through
  # a printf.

  _output=`${GLOBUS_SH_PRINTF-printf} "${var}=" ; \
    ${GLOBUS_SH_PRINTF-printf} "${value}" | \
      sed -e "s/%/%%25/g" \
	-e "s/ /+/g" \
	-e "s/&/%%26/g" \
	-e "s/@/%%40/g"`

  ${GLOBUS_SH_PRINTF-printf} ${_output}
}

###########################################################
# processReqFile
#
# Given the name of a certreq file, process and print
# contents suitabily encoded for inclusion in POST data.
#
###########################################################
processReqFile () {

  # Process the request file through three sed scripts.
  # The first cuts out the actual request from the file.
  # The second encoded characters to hex form that require it
  # Note that we double up on percents since this will later
  # get put through printf.
  # The third scripts replaces all the carriage returns with
  # their hex-encoded values.
  # XXX I'm sure these three scripts can be condensed to
  #     one or two.

  cat $1 | \
    sed -e "/BEGIN CERTIFICATE REQUEST/,/END CERTIFICATE REQUEST/ p" -e "d" |\
    sed -e "s/+/%%2B/g" \
	-e "s/ /+/g" \
	-e "s/\//%%2F/g" \
	-e "s/=/%%3D/g" |\
    sed -e ":a" \
	-e "/END+CERTIFICATE+REQUEST/bdone" \
	-e "N" \
	-e "s/\n/%%0D%%0A/" \
	-e "ba" \
	-e ":done"
}

###########################################################
# handleSuccessfulPost
#
# Handle a successful posting to the CA.
###########################################################
handleSuccessfulPost () {
  _post_out_file=$1

  _request_id=`${GLOBUS_SH_GREP-grep} "fixed.requestId =" ${_post_out_file} | ${GLOBUS_SH_AWK-awk} -F\" '{print $2; exit}'`

  echo ${_request_id} > ${REQUEST_ID_FILE}

  cat <<EOF

Your certificate request for an Alliance certificate has been successfully
sent to the Alliance Certificate Authority (CA).

You must now follow the directions on the following web page in order
to complete the request process:

http://www.ncsa.uiuc.edu/UserInfo/Alliance/GridSecurity/Certificates/Go2.html#fax
 
If you have any questions or concerns please contact Alliance consulting
at ${CONTACT_EMAIL_ADDR}

You request id is ${_request_id}. Please use it in any correspondence
with Alliance consulting.

EOF
}

###########################################################
# handleFailedPost
#
# Handle a failed posting to the CA.
###########################################################
handleFailedPost () {
  _post_out_file=$1

  ${GLOBUS_SH_GREP-grep} "connect" ${_post_out_file} > /dev/null
  if [ $? -eq 0 ]; then
    cat <<EOF

An error occurred sending your request to the NCSA CA.

If you are inside a firewall, please verify with your firewall
administrator that you are allowed to make sure httpd conntections
(https) through the firewall.

If you wish to try again at a later time (e.g. you know it's a
network problem) you may do so by running:

${PROGRAM_NAME} -resubmit

You can get help by visiting the following url:

${CONTACT_URL}

EOF
  return 1
  fi

  _server_error=`${GLOBUS_SH_GREP-grep} "fixed.unexpectedError =" $1 | ${GLOBUS_SH_AWK-awk} -F\" '{print $2; exit}'`

  if [ -n "$_server_error" ]; then
    echo "A server error occurred: $_server_error"
  fi

  cat <<EOF

An error occurred attempting to post your certificate request
to the NCSA CA. Please contact Alliance consulting for assistance
at ${CONTACT_EMAIL_ADDR}. Please include the following file
in your email as it will help in diagnosising the error:
${_post_out_file}.

Thank you and sorry for the inconvience.

EOF

  return 1
}


###########################################################
# postReq
#
#   Post the req to the web server.
#
###########################################################
postReq () {
  # https://ca.ncsa.edu/NCSAUserGridCertEnroll.html
  SERVER="ca.ncsa.edu"
  PORT="443"
  ENROLL_PAGE="/enrollment"

  
  # Temporary files
  POST_DATA_FILE=${secure_tmpdir}/$PROGRAM_NAME.$$.post_data
  POST_CMD_FILE=${secure_tmpdir}/$PROGRAM_NAME.$$.post_cmd
  POST_OUT_FILE=${secure_tmpdir}/$PROGRAM_NAME.$$.post_out

  REQ_CONTENT=`processReqFile ${REQUEST_FILE}`

  _COMMENT="host=${HOST};"

  ${GLOBUS_SH_RM-rm} -f ${POST_DATA_FILE}

  # Build the post data
  ${GLOBUS_SH_PRINTF-printf} "pkcs10Request=${REQ_CONTENT}" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "%%0D%%0A&" >> ${POST_DATA_FILE}

  printPostData "csrRequestorName" "${COMMON_NAME}" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  # Also send email to this address on certificate generation
  EXTRA_EMAIL=", paciacct@ncsa.uiuc.edu <mailto:paciacct@ncsa.uiuc.edu>"

  printPostData "csrRequestorEmail" "${USER_EMAIL}${EXTRA_EMAIL}" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "csrRequestorPhone" "${USER_PHONE}" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "csrRequestorComments" ${_COMMENT} >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  # The following are hidden values in the form
  printPostData "requestFormat" "pkcs10" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "certType" "server" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "ssl_server" "true" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "digital_signature" "true" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "non_repudiation" "true" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "key_encipherment" "true" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "data_encipherment" "true" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "reencodeSubjectName" "true" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "&" >> ${POST_DATA_FILE}

  printPostData "submit" "Submit" >> ${POST_DATA_FILE}
  ${GLOBUS_SH_PRINTF-printf} "\n\n" >> ${POST_DATA_FILE}

  # Get number of bytes we are posting
  CONTENT_LEN=`${GLOBUS_SH_WC-wc} -c ${POST_DATA_FILE} | ${GLOBUS_SH_AWK-awk} '{print $1; exit}'`
		
  # Now build the actual text for sending to the web server
  echo "POST ${ENROLL_PAGE} HTTP/1.0" > ${POST_CMD_FILE}
  echo "Content-type: application/x-www-form-urlencoded" >> ${POST_CMD_FILE}
  echo "Content-length: ${CONTENT_LEN}" >> ${POST_CMD_FILE}
  echo "User-Agent: ${USER_AGENT}" >> ${POST_CMD_FILE}
  echo "" >> ${POST_CMD_FILE}
  cat ${POST_DATA_FILE} >> ${POST_CMD_FILE}
  rm -f ${POST_DATA_FILE}

  # Sleep to give server a chance to respond
  (cat ${POST_CMD_FILE}; sleep 10) | ${SSL_EXEC} s_client -quiet -connect ${SERVER}:${PORT} > ${POST_OUT_FILE} 2>&1


  ${GLOBUS_SH_GREP-grep} "CMS Request Pending" ${POST_OUT_FILE} > /dev/null

  if [ $? -eq 0 ]; then
    handleSuccessfulPost ${POST_OUT_FILE}

    rm -f ${POST_OUT_FILE}
  else
    handleFailedPost ${POST_OUT_FILE}

    # Append the POST_CMD_FILE to the POST_OUT_FILE and then leave it so
    # that it can be used for debugging.
    cat ${POST_CMD_FILE} >> ${POST_OUT_FILE}
  fi

  rm -f ${POST_CMD_FILE}
}

getUserEmail () {
  
  _user_email=""
   
  while test "X${_user_email}" = "X" ; do
    ${GLOBUS_SH_PRINTF-printf} "Enter your full email address, e.g., user@somewhere.edu: " 1>&2
    read _user_email

    echo ${_user_email}

    if test "X${_user_email}" = "X" ; then
      echo "Email address required." 1>&2
      continue
    fi
    
    # Check for '@'
    echo ${_user_email} | grep '@' > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "Please enter your full email address with domain." 1>&2
      _user_email=""
      continue
    fi
  done
}

getUserPhone () {
  _user_phone=""

  while test "X${_user_phone}" = "X" ; do
    ${GLOBUS_SH_PRINTF-printf} "Enter your phone number (with area code): " 1>&2
    read _user_phone

    echo ${_user_phone}

    if test "X${_user_phone}" = "X" ; then
      echo "Phone number required." 1>&2
      continue
    fi
  done
}

###########################################################
# checkResubmit
#
# Check to see if we set to try resubmission.
###########################################################

checkResubmit () {
  if [ -r ${REQUEST_ID_FILE} ]; then
    cat <<EOF

Error: ${REQUEST_ID_FILE} exists.

The above file exists, indicating that you have already
successfully submitted your certificate request.

If you are certain that this is incorrect, you may remove
this file and try resubmitting again.

If you want assistance please email ${CONTACT_EMAIL_ADDR}
or visit

${CONTACT_URL}
EOF
    exit 1
  fi

  if [ ! -r ${REQUEST_FILE} ]; then
    cat <<EOF
No certificate request file found. Cannot resubmit.

You apparently have not generated a certificate request
and apparently need to run ${PROGRAM_NAME} without -resubmit.

If you want assistance please email ${CONTACT_EMAIL_ADDR}
or visit

${CONTACT_URL}
EOF
    exit 1
  fi

  if [ ! -r ${KEY_FILE} ]; then
    cat <<EOF
No key file dound. Cannot resubmit.

You apparently have not generated a certificate request
and apparently need to run ${PROGRAM_NAME} without -resubmit.

If you want assistance please email ${CONTACT_EMAIL_ADDR}
or visit

${CONTACT_URL}
EOF
    exit 1
  fi

  # Everything checks out
}

###########################################################
# printPreamble
###########################################################

printPreamble () {
  cat <<EOF

You are about to request a certificate from the Alliance
Certificate Authoriy.

Before preceeding make sure you have read the directions at:

http://www.ncsa.uiuc.edu/UserInfo/Alliance/GridSecurity/Certificates/Go.html

Press return to continue
EOF

  read _junk
}

###########################################################
# MAIN
###########################################################

readCommandLine "$@"

# Set the actual file names

#Make these absolute file names if thy are not

absolutePath () {
   _file_name="$1"

   case $_file_name in
      /*)
        echo ${_file_name}
        ;;
      *)
        echo ${PWD}/${_file_name}
    esac
}



GLOBUS_DIR="`eval echo      ${DEF_GLOBUS_DIR}`"
CERT_FILE="`eval echo       ${DEF_CERT_FILE}`"
KEY_FILE="`eval echo        ${DEF_KEY_FILE}`"
REQUEST_FILE="`eval echo    ${DEF_REQUEST_FILE}`"
REQUEST_ID_FILE="`eval echo ${DEF_REQUEST_ID_FILE}`"


GLOBUS_DIR="`absolutePath      ${GLOBUS_DIR}`"
CERT_FILE="`absolutePath       ${CERT_FILE}`"
KEY_FILE="`absolutePath        ${KEY_FILE}`"
REQUEST_FILE="`absolutePath    ${REQUEST_FILE}`"
REQUEST_ID_FILE="`absolutePath ${REQUEST_ID_FILE}`"




checkGlobusSystem

if [ "${RESUBMIT}" = "FALSE" ]; then
  # Only set up the Globus Directory for users.
  if [ -z "${SERVICE}" ] ; then
    setupGlobusDir
  fi

  check4Certs
fi

trap abort_cleanup 0

if [ "${RESUBMIT}" = "TRUE" ]; then
  checkResubmit
else
  printPreamble

  if [ -z "${SERVICE}" ] ; then
    COMMON_NAME="`getUserCN`"
  else
    COMMON_NAME="`getHostCN`"
  fi

  # Check for abort
  if [ -z "${COMMON_NAME}" ]; then
    exit 1
  fi
fi

  # Additional stuff for ncsa-cert-req
  USER_EMAIL=`getUserEmail`
  USER_PHONE=`getUserPhone`
  echo ""
  echo ""

  createCerts
  RET=$?

  COMMON_NAME="`echo ${SUBJECT} | ${GLOBUS_SH_SED-sed} -e 's|^.*/CN=||'`"

postReq

trap cleanup 0

exit ${RET}
