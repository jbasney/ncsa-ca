#!/usr/bin/perl -w
#
# Copyright (c) 2002 The Regents of the University of California. All
# rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met: 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following
# disclaimer. 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution. 3. All advertising materials mentioning features or use
# of this software must display the following acknowledgement: This
# product includes software developed by the San Diego Supercomputer
# Center and its contributors. 4. Neither the name of the Center nor the
# names of its contributors may be used to endorse or promote products
# derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
#  Script name: cacl (Certificate Authority CLient)
#  Written by: William J. Link
#  Date: June, 2000
#
#  This script can be used to acquire digital certificates issued by
#  the NPACI/SDSC developed certificate management system.  It also
#  creates a Globus enviroment for the user by creating a .globus
#  directory within the user's home directory.  The user's encrypted
#  cerificate key and the digital certificate in both pem and PKCS#12
#  format are put into the .globus directory.
#

$O = "National Center for Supercomputing Applications";
#$GRIDMAPFILE = "/afs/ncsa/common/etc/grid-security/grid-mapfile";
$GRIDMAPFILE = "/afs/ncsa/common/etc/grid-security/grid-mapfile.stub";
$USER_CERT_DIR = ".globus";
$USER_CERT_DIR_OLD = ".globus.old";
$USER_P12_CERT_FILE = "usercert.p12";
$USER_CERT_FILE = "usercert.pem";
$USER_KEY_FILE = "userkey.pem";

$PKIAPPS = "/usr/local/apps/pki_apps";
$OPENSSL = "/usr/bin/openssl";
$CONFIG = "$PKIAPPS/CA/user.cnf";
$CACERT = "$PKIAPPS/CA/ca.pem";
$CA = "bosco.ncsa.uiuc.edu";
$PORT = 3434;
$GLMV = 0;
$MINPWDLEN = 8;
$RUNBY = `logname`;
chomp ($RUNBY);

#
# Move to the user's home directory before doing anything.
#

chdir($ENV{"HOME"}) || die "Can't get to your home directory. \n";

#
# Check for conditions which will prevent this script from running.
#

if (! -e $OPENSSL) {
    print ("\n");
    print ("You can not request a cert from this machine because \n");
    print ("$OPENSSL is not available. \n");
    print ("\n");
    exit 1;
}

if ((! -e $CONFIG) || (! -e $CACERT)) {
    print ("\n");
    print ("You can not request a cert from this machine because files \n");
    print ("needed from $PKIAPPS/CA are not available. \n");
    print ("\n");
    exit 1;
}

if (-e $USER_CERT_DIR && -e $USER_CERT_DIR_OLD) {
    print ("\n");
    print ("You already have both $USER_CERT_DIR and $USER_CERT_DIR_OLD directories. \n");
    print ("You will have to clean up your home directory Globus 
environment \n");
    print ("before you can rerun this program. \n");
    print ("\n");
    exit 1;
}

if (-e $USER_CERT_DIR) {
    print ("\n");
    print ("You already have a $USER_CERT_DIR directory.  It will be moved to \n");
    print ("$USER_CERT_DIR_OLD and a new $USER_CERT_DIR directory will be created. \n");
    print ("\n");
    rename ($USER_CERT_DIR,$USER_CERT_DIR_OLD);
    $GLMV = 1;
}

$GRIDMAP_ENTRY = `grep $RUNBY $GRIDMAPFILE`;
chomp($GRIDMAP_ENTRY);
if (! $GRIDMAP_ENTRY) {
    print ("grid-mapfile entry not found. \n");
    exit 1;
}

if ($GRIDMAP_ENTRY =~ /O=$O/) {
    $DN = substr($GRIDMAP_ENTRY,0,(length($GRIDMAP_ENTRY))-(length($RUNBY)+1));
    $DN =~ s/\"//g;
    $CN=substr($DN,index($DN,"CN=")+3);
} else {
    print ("There is no grid-mapfile entry for user: $RUNBY and O=$O. \n");
    exit 1;
}

system ("stty -echo");
print ("Please enter your kerberos password: ");
$LOGINPWD = <STDIN>;
chomp ($LOGINPWD);

#
# Precede a backslash in the password with lots of escapes, precede
# double quotes with a single escape character, and enclose the password
# with double quotes to prevent "special characters" from being stripped
# out when openssl creates the req.pem file.
#
$LOGINPWD=~ s/\\/\\\\/g;
$LOGINPWD=~ s/"/\\"/g;
$LOGINPWD= "\"$LOGINPWD\"";

$ENCPWD = "a";
$ENCPWD2 = "b";
print ("\n \n");
print ("Next you will be prompted to enter a password which will serve \n");
print ("as both the encryption key for your certificate's private key \n");
print ("and as the 'export password' for your PKCS#12 converted \n");
print ("certificate.  Please choose a password that you can remember, \n");
print ("you will need to use it in the future. \n");
print ("\n");
while ($ENCPWD ne $ENCPWD2) {
    $ENCPWD = "pwd1";
    $ENCPWD2 = "pwd2";
    print ("\n");
    print ("Please enter your private key encryption password: ");
    $ENCPWD = <STDIN>;
    chomp ($ENCPWD);
    if (length($ENCPWD) < $MINPWDLEN) {
       print ("\n\nPrivate key encryption passwords must be at least 
eight  \ncharacters in length, please try again.\n");
    } else {
       print ("\n");
       print ("Verifying private key password, please reenter password: ");
       $ENCPWD2 = <STDIN>;
       chomp ($ENCPWD2);
       print ("\n");
       if ($ENCPWD ne $ENCPWD2) {
       print ("\nThe passwords did not match, please try again.\n");
       }
    }
}

system ("stty echo");
print ("\n");

mkdir ($USER_CERT_DIR,0700);
$OK = chdir($USER_CERT_DIR);
if (! $OK) {
    print "Can't get to your $USER_CERT_DIR directory. \n";
    exit 1;
}

#
# Write out the private key encryption password for use by openssl
# when generating the key and certificate request.  It will be deleted
# after it has been used for the key encryption.
#

open(OUT, ">epwd");
print(OUT "$ENCPWD");
close(OUT);

#
# Stream edit the standard cert request config file to insert information
# gathered from STDIN and from the user's /etc/passwd file entry, write
# the modified config file out into the "conf" file.
#

open(IN,$CONFIG) || die "Can't open $CONFIG file. \n";
open(OUT,">conf" || die "Can't open $USER_CERT_DIR/conf file for writing. \n");
select(OUT);
while (<IN>) {
s/CommonName/$CN/;
s/LoginName/$RUNBY/;
s/ChallengePwd/$LOGINPWD/;
print;
}
close(IN);
close(OUT);
select(STDOUT);

#
# Generate a .rnd file to be used as a randon number seed, create the cert
# request, and encrypt it using the CA's cert.
#

$RNUM = rand;
system ("echo $RNUM | /bin/cat > rnseed");
system ("echo `ps -el` | gzip >> rnseed");
system ("echo `/bin/date` | /bin/cat >> rnseed");
system ("$OPENSSL genrsa -rand rnseed > /dev/null 2>&1");
system ("$OPENSSL req -new -config conf -passout file:./epwd -keyout $USER_KEY_FILE -out req.pem > /dev/null 2>&1");
chmod (0400,$USER_KEY_FILE);
system ("$OPENSSL smime -encrypt -des3 -in req.pem -out ereq $CACERT");
unlink ("conf","epwd","req.pem","rnseed");

#
# Set up a socket connection to the CA daemon running on ca.sdsc.edu and send
# the certificate request.
#

use IO::Socket;
$SOCKET = new IO::Socket::INET (PeerAddr => $CA,
                                 PeerPort => $PORT,
                                 Proto    => 'tcp');

if (! $SOCKET) {
    chdir($ENV{"HOME"}) || die "Can't cd back to home directory. \n";
    system ("rm -rf $USER_CERT_DIR");
    if ($GLMV) {
       rename ($USER_CERT_DIR_OLD,$USER_CERT_DIR);
    }
    print ("Can not connect to $CA: $! \n");
    exit 1;
}

$MSG=`/bin/cat ereq`;
select($SOCKET);
send($SOCKET,$MSG,0);
send($SOCKET,"All done\n",0);
unlink ("ereq");

#
# Get a reply from the CA daemon.  If the first eight bytes is "Success "
# the rest of the message is the cert, which can be written out to disk
# in the current directory as $USER_CERT_FILE.  Next the encrypted
# private key is sent to the CA daemon for safe keeping, a PKCS#12
# copy of the cert is made, and the local conf and cert request files are
# deleted.  If the first eight bytes is "Error   " then something went
# wrong, print the rest of the message, which is an error message, to
# STDOUT.
#

recv($SOCKET,$BUFF,8,0);
if ("$BUFF" eq "Error   ") {
     select (STDOUT);
     print ($BUFF);
     recv($SOCKET,$BUFF,5000,0);
     print ("$BUFF \n");
     close($SOCKET);
     chdir($ENV{"HOME"}) || die "Can't cd back to home directory. \n";
     system ("rm -rf $USER_CERT_DIR");
     if ($GLMV) {
        rename ($USER_CERT_DIR_OLD,$USER_CERT_DIR);
     }
     exit 1;
} elsif ("$BUFF" eq "Success ") {
      open (CERTFILE, ">$USER_CERT_FILE");
      select (CERTFILE);
      local $/;
      undef ($/);
      while (<$SOCKET>) {
         print ($_);
      }
      close(CERTFILE);
      open(OUT, ">epwd");
      print(OUT "$ENCPWD");
      close(OUT);
      $KEY = `/bin/cat $USER_KEY_FILE`;
      send($SOCKET,$KEY,0);
      send($SOCKET,"All done\n",0);
      close($SOCKET);
      select (STDOUT);
      print ("\n");
      system ("$OPENSSL rsa -passin file:./epwd -in $USER_KEY_FILE -outform PEM -out key.pem > /dev/null 2>&1");
      system ("$OPENSSL pkcs12 -export -in $USER_CERT_FILE -inkey key.pem -passout file:./epwd -out $USER_P12_CERT_FILE -name \"NCSA OpenSSL Certificate\"");
      chmod (0400,$USER_P12_CERT_FILE,$USER_CERT_FILE);
      unlink ("epwd","key.pem");
      print ("You now have a $USER_CERT_DIR directory containing the following files: \n");
      print ("\n");
      print ("$USER_P12_CERT_FILE - Your digital certificate and private key in \n");
      print ("               a PKCS#12 format certificate \n");
      print ("\n");
      print ("$USER_CERT_FILE - Your digital certificate, signed by the CA \n");
      print ("               daemon \n");
      print ("\n");
      print ("$USER_KEY_FILE  - Your encrypted private key matching the \n");
      print ("               public key contained in your $USER_CERT_FILE \n");
      print ("\n");
      print ("\n");
      print ("********************************************************** \n");
      print ("\n");
      print (" YOUR CERTIFICATE IS VALID FOR FOUR YEARS, DO NOT FORGET \n");
      print (" YOUR PRIVATE KEY ENCRYPTION PASSWORD AND, DO NOT DELETE \n");
      print (" YOUR $USER_CERT_DIR DIRECTORY. \n");
      print ("\n");
      print ("********************************************************** \n");
      print ("\n");
} else {
     select (STDOUT);
     print ("Can't recognize reply from CA daemon. \n");
     close($SOCKET);
     chdir($ENV{"HOME"}) || die "Can't cd back to home directory. \n";
     system ("rm -rf $USER_CERT_DIR");
     if ($GLMV) {
        rename ($USER_CERT_DIR_OLD,$USER_CERT_DIR);
     }
     exit 1;
}
exit 0;

